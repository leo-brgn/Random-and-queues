---
title: "Rapport"
output: pdf_document
date: '2022-03-07'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# installation du package randtoolbox s'il n'est pas installe
if(!require(randtoolbox)) install.packages("randtoolbox")
# chargement du package randtoolbox
library(randtoolbox)
# chargement du module generateurs.R
# source('~/Documents/INSA/IFA3/PROB/TP-Probas/generateurs.R')
source('generateurs.R')

# definition des parametres
sVN <- 3454 # graine pour la methode de Von Neumann
sMT <- 1502 # graine pour la methode de Mersenne-Twister
Nsimu <- 1000 # nombre de simulations (nombre d'entiers par sequences generee)
Nrepet <- 20 # nombre de repetitions (nombre de sequences generees)
```

## Partie 1

### Question 2.1

```{r, echo=FALSE}
# appel des fonctions de génréations de nombres aléatoires :
vn <- VonNeumann(Nsimu, Nrepet, sVN) 
mt <- MersenneTwister(Nsimu, Nrepet, sMT)
ru <- randu(Nsimu, Nrepet, sVN)
stm <- standardMinimal(Nsimu, Nrepet, sVN)

# max valeur possible 
max_mersenne <- 2^32-1
max_vn <- 9999
max_ru <- 2^31-1
max_stm <- 2^31-2

# Visualiation de donnees generees sous forme des histogrammes (1ere colonne) 
# sur le meme graphique
par(mfrow=c(2,2)) #
hist(vn[,1], breaks=seq(0,max_vn,length=20), xlab='', main='Von Neumann')
hist(mt[,1], breaks=seq(0,max_mersenne,length=20), xlab='', 
     main='Mersenne Twister')
hist(ru[,1], breaks=seq(0,max_ru,length=20), xlab='', main='RANDU')
hist(stm[,1], breaks=seq(0,max_stm,length=20), xlab='', 
     main='Standad Minimal')

```

La méthode de Von Neumann ne semble pas satisfaisante pour générer des nombres aléatoires suivant une loi uniforme. On peut remarquer des valeurs absorbantes. Les trois autres méthodes semblent quant à elles fournir des résultats plutôt satisfaisants. On peut supposer d'après le graphique que l'écart-type est assez faible pour ces trois méthodes.

### Question 2.2

```{r, echo=FALSE}
# Visualiation de donnees generees sous forme des nuages des points (scatterplot) 
# sur le meme graphique
# chaque donnee est prise en fonction de la donnee precedente
par(mfrow=c(2,2))
plot(vn[1:(Nsimu-1),1], vn[2:Nsimu,1], xlab='VN(i)', ylab='VN(i+1)', 
     main='Von Neumann')
plot(mt[1:(Nsimu-1),1], mt[2:Nsimu,1], xlab='MT(i)', ylab='MT(i+1)', 
     main='Mersenne Twister')
plot(ru[1:(Nsimu-1),1], ru[2:Nsimu,1], xlab='RU(i)', ylab='RU(i+1)', 
     main='RANDU')
plot(stm[1:(Nsimu-1),1], stm[2:Nsimu,1], xlab='STM(i)', ylab='STM(i+1)', 
     main='Standard Minimal')
```

Ce mode de visualisation nous permet de voir si la valeur donnée par l'algorithme dépend ou non de la valeur précédente. On remarque que pour tous les algorithmes sauf celui de Von Neumann, il ne semble pas y avoir de corrélation entre les valeurs de rang N et N+1. En effet, on ne voit pas de courbe ou de droite se dessiner et les valeurs sont au contraire très dispersées sur les graphiques.

### Question 3

```{r}
fr_mt <- Frequency(mt,32)
fr_vn <- Frequency(vn,14)
fr_ru <- Frequency(ru,31)
fr_stm <- Frequency(stm,31)
p_mt <- 2 * (1-pnorm(fr_mt))
p_mt <- sum(p_mt)/length(p_mt)
p_vn <- 2 * (1-pnorm(fr_vn))
p_vn <- sum(p_vn)/length(p_vn)
p_ru <- 2 * (1-pnorm(fr_ru))
p_ru <- sum(p_ru)/length(p_ru)
p_stm <- 2 * (1-pnorm(fr_stm))
p_stm<- sum(p_stm)/length(p_stm)
```

| Algorithme | Von Neumann | Mersenne Twister | RANDU | Standard minimal |
|------------|-------------|------------------|-------|------------------|
| P_valeur   | 0.00018     | 0.507            | 0.506 | 0.467            |

Pour valider l'hypothèse que l'algorithme produit une séquence aléatoire, il faut 
que P_valeur soit strictement supérieur à 0.01. De ce fait, l'algorithme de Von
Neumann n'est clairment pas satisfaisant. Toutefois les trois autres algorithmes
le sont.
